[Flask / Python]
General Information & Licensing
Code Repository
    https://github.com/pallets/flask.git
License Type
    three clause BSD License
License Description
    Allow to modify
    Allow to distribute
    Allow to place warranty
License Restrictions
    Not allow to use trademark
    Not allow to hold liable




Magic ⋆★͎۪۫｡˚۰˚☽˚⁀➷｡˚★彡͎۪۫⋆ ༄
Dispel the magic of this technology. Replace this text with some that answers the following questions for the above tech:
How does this technology do what it does? Please explain this in detail, starting from after the TCP socket is created
Where is the specific code that does what you use the tech for? You must provide a link to the specific file in the repository for your tech with a line number or number range.
If there is more than one step in the chain of calls (hint: there will be), you must provide links for the entire chain of calls from your code, to the library code that actually accomplishes the task for you.
Example: If you use an object of type HttpRequest in your code which contains the headers of the request, you must show exactly how that object parsed the original headers from the TCP socket. This will often involve tracing through multiple libraries and you must show the entire trace through all these libraries with links to all the involved code.

*This section will likely grow beyond the page
—--------------------- first draft------------------------

Flask as a web application framework not only be referenced as a micro framework but
also written in python which was familiar to all the members of the group. Choosing 
it as our framework just makes things a lot easier. 

Once a connection was created, Flask will provide users with the tools needed for 
building a web application or in this case a response cycle. The application will 
receive requests from the users and sends back a response based on the function in 
the form of HTML, JSON, XML, etc.
https://github.com/pallets/flask/blob/main/src/flask/app.py

route(): decorator to tell Flask what URL should trigger our function.
The function returns the message we want to display in the user’s browser
https://github.com/pallets/flask/blob/main/src/flask/scaffold.py


Flask as a web application framework not only be referenced as a micro framework but 
also written in python which was familiar to all the members of the group. Choosing it 
as our framework just makes things a lot easier. 

Once a connection was created, Flask will provide users with the tools needed for building 
a web application or in this case a response cycle. The application will receive requests 
from the users and sends back a response based on the function in the form of HTML, JSON, XML, etc.
https://github.com/pallets/flask/blob/main/src/flask/app.py

route(): decorator to tell Flask what URL should trigger our function.
Mainly used with render_template() to display in the user’s browser
https://github.com/pallets/flask/blob/main/src/flask/scaffold.py#L423

render_template(): Render a template by name with the given context by calling the _render() function. 
Most of the time it will be rendering HTML based on what route() decoded
https://github.com/pallets/flask/blob/main/src/flask/templating.py#L135

_render(): Update and returns the newly templet
https://github.com/pallets/flask/blob/main/src/flask/templating.py#L127

send_from_directory(): Returns send_from_directory from werkzeug library
Send a file from within a directory using:func:`send_file`
https://github.com/pallets/flask/blob/main/src/flask/helpers.py#552

send_file(): process and send the content to the client
https://github.com/pallets/werkzeug/blob/main/src/werkzeug/utils.py#549

request.args(): returns parsed url as ~werkzeug.datastructures.ImmutableMultiDict
https://github.com/pallets/werkzeug/blob/main/src/werkzeug/sansio/request.py#170

redirect() 

trace 

Flask is imported into the /app.py directory. What we currently have is multiple 
python decorator which checks and gives a response based on the route and the request type.

line 25 checks the URL and GET type. 
Returns the home_page HTML by calling render_template(). 

line 30, checks the URL and GET type. Execute postgresql_system() based on the operator. 
In this case, operation is "getLeaderboard" returns the top 10 users with the highest win rate.
Returns the leaderboard HTML by calling render_template(). The leaderboard.html has been updated with the top 10 users.

line35 gets the javascript information by calling send_from_directory()

line39 checks the URL and GET type. Creates a tuple of questions by calling generate_question(). 
Update and returns the local_problem HTML with the newly generated question by calling render_template(). 

line46 checks the URL and GET type. Execute postgresql_system() based on the operator. 
In this case, the operation is “getUser”. This checks if the user id exists and updates the user_profile_template HTML with the user’s info by calling render_template() else return 404. 
Information includes the number of wins and games played.

line57, function for users to join the game lobby. It receives users' IDs by calling request.args from flask and checks for existing lobbies if the id is verified in the database.
returns a redirect() function with url.
line84, flask will run with socket on port 80.









