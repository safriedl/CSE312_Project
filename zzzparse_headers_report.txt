[Flask / Python]
General Information & Licensing
Code Repository
    https://github.com/pallets/flask.git
License Type
    three clause BSD License
License Description
    Allow to modify
    Allow to distribute
    Allow to place warranty
License Restrictions
    Not allow to use trademark
    Not allow to hold liable




Magic ⋆★͎۪۫｡˚۰˚☽˚⁀➷｡˚★彡͎۪۫⋆ ༄
Dispel the magic of this technology. Replace this text with some that answers the following questions for the above tech:
How does this technology do what it does? Please explain this in detail, starting from after the TCP socket is created
Where is the specific code that does what you use the tech for? You must provide a link to the specific file in the repository for your tech with a line number or number range.
If there is more than one step in the chain of calls (hint: there will be), you must provide links for the entire chain of calls from your code, to the library code that actually accomplishes the task for you.
Example: If you use an object of type HttpRequest in your code which contains the headers of the request, you must show exactly how that object parsed the original headers from the TCP socket. This will often involve tracing through multiple libraries and you must show the entire trace through all these libraries with links to all the involved code.

*This section will likely grow beyond the page
—--------------------- first draft------------------------

Flask will provide users with the tools needed for building 
a web application or in this case a response cycle. The application will receive requests 
from the users and sends back a response based on the function in the form of HTML, JSON, XML, etc.
https://github.com/pallets/flask/blob/main/src/flask/app.py

Flask is imported into the /app.py directory. What we currently have is multiple python 
decorator which checks and gives a response based on the route and the request type.

The decorator we use to check URLs is route().
route():  it is a decorator to tell Flask what URL should trigger our function. 
It also calls add_url_rule() which sets the view function to the endpoint.

route()
https://github.com/pallets/flask/blob/main/src/flask/scaffold.py#L423
add_url_rule()
https://github.com/pallets/flask/blob/main/src/flask/scaffold.py#L455

route() function define the request methods and the triger routes.
We reads it's header using request.args

flask.Request.args(): A MultiDict with the parsed contents of the query string. 
Including the following:
    query_string: The headers received with the request
    url_charset: The charset that is assumed for URLs. Defaults to the value of :attr:`charset
    encoding_errors: the error handling procedure for errors
    parameter_storage_class: The type to be used for dict values from the incoming WSGI environment.

From the header, we checks for specific datas and in the case it matches with what we have
in the data base, we execute the corresponding function or else we sends 404.

After we execute the functions that were decided for the URL, we update the
pages and uses redirect(). It brings back to the first phase where route() receiving request.

helper-redirect(): Create a redirect response object and make it easier to call the redirect form flask 
https://github.com/pallets/flask/blob/main/src/flask/helpers.py#L226

we can also call flask-redirect directly instead of using the helper function. Both end up the same.
flask-redirect(): Calls the werkzeug redirect function
https://github.com/pallets/flask/blob/main/src/flask/app.py#L2038

_wz_redirect(): Returns response object. Supported codes are 301, 302, 303, 305, 307, and 308. It also ignore the call if response is None.
https://github.com/pallets/werkzeug/blob/main/src/werkzeug/sansio/utils.py#L244

flask_socketio.SocketIO.run (): Runs the SocketIO web server on the given port.
https://github.com/miguelgrinberg/Flask-SocketIO/blob/main/src/flask_socketio/__init__.py#L554